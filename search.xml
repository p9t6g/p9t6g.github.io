<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[noip2020复习&总结]]></title>
    <url>%2F2020%2F10%2F27%2FNOIP%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[终末之章 前言走了,回来了,不管如何,这条路似乎已经延伸得很漫长了,从兴趣,变成兼修,变成接近专修,又变回兴趣,,这中间的路太长,以至于虽然百味杂陈,却说不出什么感想. 除了爱与恨以外,我有时候觉得信息学已经成为了我生命中无法割舍的一部分了,不知是好是坏 这样长篇的总结,大概在我还能被称作所谓的竞赛选手时,不会有多少了 亦是最后的挣扎,亦是痛心的告别,希望这条路还能再延伸那最后的一段吧 特殊思路 环断边:对于环上存在的问题,可以考虑将环倍增然后断为链.一般用于从某点开始对环进行遍历的问题 权值与下标交换:将答案设为下标,将下标放入数组的权值.适用于答案极值偏小,但是某一下标过大且表达的信息过于离散的问题(如JOI 2020 final-集邮比赛),如果仍然放不下的话可以考虑二分答案 对于元素独立,询问独立且多个限制之间互相独立的问题,可以先通过遍历来筛选元素,且降低元素的特异性,使得后续处理与存储更为优秀,实际可以总结为提取出所需要元素的有效信息,优化存储/处理方式 做题思想解决后效性首先在设置状态时,要搞清楚哪些变量之间互不影响,前后计算没有任何影响,一般会将其设为状态 其次,对于设置完的状态出现后效性问题,有两种解决方式 再设置一个下标来分开各个选择以消除后效性(因为可获得之前选择的更多信息所以后效性不影响) 类似于上一种,可以尝试 将状态之间转移的关系提前计算为一个数组,并且在这个数组中处理后效性.这种做法要求各个状态之间的转移经常规律性变化(类似于矩阵) 基础算法高精度一个工具,当计算的数据达到需要的程度时使用即可 枚举算法一般出现在当前题目的计算要求过于复杂,且数据范围极小时 直接对于一些可能出现状况极少的变量进行枚举 递推通过特定方式进行多次运算,最终解决复杂问题 与dp的主要区别在于是否动态比较更改答案,但是信息学一般不做区分 一般性递推按一个线性方式遍历数据然后以此不断更新答案获得最优解 组合计数由于研究对象会有一定限制,所以利用其他的数组实现阶段性地递推或者提高状态描述维度以解决限制 部分博弈问题通过合适的状态设定获得博弈图,然后根据题目规则来获得当前博弈图的必胜必败态的关系,然后由唯一确定的最终状态(必胜态)逆向推导获得答案 由于递推非常具有规律性,所以经常可以将递推过程简化 dp详见dp类 递归仅一种实现方式 分治主要标志: 当数据小到一定程度(即子问题)时,问题易解决且问题答案可以通过子问题答案合并获得 CDQ当一个数组上的计数类问题或最值问题存在多个要求且相互独立时可以使用CDQ来依次解决(一般第一维在最外层排序解决,第二维在分治过程中排序解决,第三维使用线段树或树状数组解决) 当相互独立的限制超过三个时CDQ一般不是最优解 最优解类分治一般下一层所得结果可以限制上层需要询问答案的范围 点分治适用于解决大规模树上路径信息的问题 边分治与点分治类似,更适合解决边上问题 点分树一种将树的最大深度控制在严格$log(n)$的重构方式,适用于与树原形态无关的问题 贪心区间最大覆盖个数在一个数轴上按照区间覆盖,求最大能放下的区间个数 按右端点排序依次取 区间选点在数轴上放点使得所有给定区间内都有点 按右端点排序,尽量往右边放 区间覆盖在数轴上用尽可能少的区间表示所有给定区间的并 按左端点排序,依次查询合并 搜索剪枝 减少搜索范围 当前状态无法获得更优解 当前状态无法得解 舞蹈链!!!!!!!!!!!!杂项莫队适用于可以在$O(1)$的时间将区间$[L,R]$的答案转移得到$[L,R+1]$与$[L-1,R]$的答案时 奇偶性优化 对于奇数块的询问,按$R$从小到大排序，对于偶数块的询问，按$R$从大到小排序 三分适用于答案存在于一个单峰函数的极值问题上 dp坐标类 所有方案数 一条最优路径 两条最优路径(状态中同时表示两条路径的到达点,一同转移) 提高组dp不一定会很复杂,所以尝试思考高维的状态来表达 线性LIS 单调队列优化 值域二分优化 LCS 同样,注意考虑高维状态来维护 区间 对于环上问题可将环拓展为两倍,然后取区间长度为n的答案的最优值 背包01 f[i]:使用i的空间的最大价值\\ f[j]=max(f[j],f[j-c[i]]+v[i])12345for(int i=1;i&lt;=n;i++)&#123; for(int j=m;j&gt;=1;j--)&#123; f[j]=max(f[j],f[j-c[i]]+v[i]); &#125;&#125; 完全 f[i]:使用i的空间的最大价值\\ f[j]=max(f[j],f[j-c[i]]+v[i])12345for(int i=1;i&lt;=n;i++)&#123; for(int j=c[i];j&lt;=m;j++)&#123; f[j]=max(f[j],f[j-c[i]]+v[i]); &#125;&#125; 多重 f[i]:使用i的空间的最大价值\\ f[j]=max_{k=1}^{num_i}(f[j],f[j-k*c[i]]+k*v[i])1234567for(int i=1;i&lt;=n;i++)&#123; for(int j=m;j&gt;=1;j--)&#123; for(int k=1;k&lt;=num[i];k++)&#123; f[j]=max(f[j],f[j-k*c[i]]+k*v[i]); &#125; &#125;&#125; 二进制优化 将k个i物品拆成许多个包含$2^x$个的i物品的物品集,当作新物品,将多重转化为01 单调队列优化 由于单调队列基本的dp方程并非仅与当前枚举变量有关,所以改变枚举方式 令$\Large g_{x,y}=f_{i,x\cdot c_i+y}$,$\Large g’_{x,y}=f_{i-1,x\cdot c_i+y}$ \Large g_{x,y}=max(g'_{x-k,y}+k\cdot v)\\ \Large g_{x,y}=max(g'_{x-k,y}-(x-k)\cdot v)+x\cdot v这里注意到max内式子只与x-k有关,并且我们之前的枚举会访问他,所以可以直接单调优化 混合对于不同的物品使用不同的方程dp即可 二维费用与一维类似,两种限制分别枚举,不冲突 分组背包先枚举组,再枚举组内物品,最后枚举消耗(也就是f数组的参数) 依赖背包对于每一个主件及其附带附件,将所有可能的购买情况记录下来,当作分组背包做 对于多叉树,先算子节点,再算父节点 最大子序列/子矩阵及类似问题一维简单dp,类似01背包的做法 二维对于规定大小的类型,可以直接前缀合优化解决 对于未规定大小的类型,首先枚举矩形的左右边界,然后将上下当做一维问题解决 注意n,m范围,有可能会出现特殊情况,如m&lt;=2 树型二叉树由于二叉树每个点儿子都极少,所以可能存在枚举左右儿子分配资源(消耗)或者枚举左右01分别状况的dp 子树影响有些时候看似题目本身存在后效性,但是可以通过一定的理论证明来优化dp方程或者增加状态,以消除后效性 如Luogu P2899 多次实际只是dp问题无意义的独立嵌套,需要注意不忘记这一做法即可.对于信息过于复杂时,可以尝试考虑通过多次dp来简化问题 如SCOI2009-粉刷匠,JZOJ 1303-骑士 状压状压题目的标志性一般极其明显,当数据范围极小但是每个点之间的选择状态又会造成影响时,可以考虑状压 很多时候仅仅压缩一维状态并不能设出无后效性的状态,所以可以设置类似于最后到达哪个点这样类似的第二维甚至第三维 单调队列将dp方程写出后进行变形,如果最后能够做到使min/max中不存在与i有关的变量的可以进行单调队列优化 斜率优化对于一类动态规划问题,若可以将转移方程变形为如下形式,则可以将决策点转化为二维坐标系上具象化的点 k_1x+f[i]*k_2+b=y其中$k_1,b$与当前点有关,$x,y$与决策点有关,而$k_2$为常数,仅与方程有关 方程变形过程中主要注意将与$i$有关,与$j$有关,与$i,j$有关的量分开 斜率单调&amp;决策点单调决策点单调即x单调 直接使用单调队列维护 斜率不单调|决策点不单调CDQ分治或平衡树解决 决策单调性对于最优化dp(即转移只来自一个点,而非许多状态的加和),若通过理论分析或者打表分析得到决策点只向一个方向变化的结论,即可只从上一个状态的决策点向后枚举转移 对于任何最优化dp都可以尝试考虑单调性优化 四边形不等式本质就是决策单调性,但是形式稍特殊,一般还是使用打表分析决策点是否单调 形式类似区间dp]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半搜索(meet in the middle)]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[简单的思想,强大的能力,可惜可拓展范围不广 前置知识大概木有吧,能学到这个东西大概你也会DFS了吧 进入正题折半搜索,看起来很好玩的样子,我们用一道题来了解个大概 例题题目描述luogu-P4799 世界冰球锦标赛 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。 给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。 题目简述N场比赛,M元,每场价格不一定相同,求最多有多少种买的方案 分析例题这是一道看起来十分简单的DFS题,但是,!!! 再看一眼 ou,shit! $2^{40}$好像有点大啊 正式引入折半搜索是一种针对方案计算而存在的算法,可以将时间复杂度开个根号 我们还是用例题来讲, 我们尝试将搜索的对象分为两部分,然后分别对其进行搜索,再分别记录结果 但是得到了这样的结果,我们并没有真正的结果啊,怎么办? 对于第一部分,我们定义一个方案$A$,第二部分定义一个方案$B$,满足$A+B&lt;=M$,那么是不是第二部分任何小于$B$的方案都可以与$A$搭配? 那么我们将左右两部分得出的方案分别按花费排序,那就简单了,双指针直接秒杀. 再分析一波时间复杂度,$DFS:O(2^{n/2}),sort:O(2^{n/2} \cdot (n/2)),双指针: O(2^{n/2} \cdot (n/2))$ 刚好$1e7$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define ull unsigned long long#define db double#define ldb long db#define si short int#define bl bool#define mem(a) memset(a,0,sizeof(a))#define mee(a,b) memset(a,b,sizeof(a))#define setnum(a,b,c) for(int kkk=1;i&lt;=b;i++)a[kkk]=c[kkk];#define setnums(a,b,c) for(int kkk=1;kkk&lt;=b;kkk++)a[kkk]=c;#define maxn 10000005#define maxm#define inf 0x7fffffff#define r(a) a=read()#define w(a) write(a);puts("")#define W(a) write(a);printf(" ")#define For(a,b,c) for(int a=b;a&lt;=c;a++)using namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll n,m,v[maxn],a[maxn],b[maxn];void Dfs(ll num,ll lim,ll val)&#123; if(num==lim+1)&#123; if(val&gt;m)return; if(lim==n/2)a[++a[0]]=val; if(lim==n )b[++b[0]]=val; return; &#125; Dfs(num+1,lim,val); Dfs(num+1,lim,val+v[num]);&#125;int main()&#123; n=read(); m=read(); for(int i=1;i&lt;=n;i++) v[i]=read(); Dfs(1,n/2,0); Dfs(n/2+1,n,0); sort(a+1,a+a[0]+1); sort(b+1,b+b[0]+1); ll x=a[0],ans=0; for(int i=1;i&lt;=b[0];i++)&#123; while(a[x]+b[i]&gt;m)x--; ans+=x; &#125; cout&lt;&lt;ans; return 0;&#125; 算法介绍由上面这道题想必都可以对这个算法了解一些了吧,下面进行具体讲解 适用范围这个算法适用于一些类似于N个物品由多种状态(如取与不取),由一定限制,问总共多少种方案. 上述时间复杂度大部分情况是$x^n$的时间(x是常数,也就是单一物品状态数) 思考方式首先思考最为简单的暴力 然后通过将搜索范围折半分开的方式分别求出状态 但是其中会由一部分问题没有那么单纯,比如说给出的另外一道例题:luogu-P3067 平衡的奶牛群就会涉及到通过状态压缩来判重的手法. 最后对状态进行排序,并依次匹配 习题luogu-P4799 世界冰球锦标赛 luogu-P3067 平衡的奶牛群]]></content>
      <categories>
        <category>学习笔记</category>
        <category>DFS/BFS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>DFS/BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学入门介绍与整体阐述]]></title>
    <url>%2F2019%2F06%2F18%2F%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%95%B4%E4%BD%93%E9%98%90%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[To be continued. 1 What exactly is OI OI是Olympiad in Informatics的简称,指的是”信息学奥林匹克竞赛”，是一项在中学生中广泛开展的一门学科竞赛，和物理、数学等竞赛性质相同。 by度娘 信息?在原意上,信息是指人与人之间传输的不真实存在的对象. 现在这个词语会有无数种翻译,而我们在其中选出了针对计算机的定义 有目的地标记在通讯系统或计算机的输入上面的信号 by 度娘 again 信息学?那么信息学的定义就显而易见了 一种关于在通讯系统或计算机上输入信号的学习 by p9t6g 而落实到现实生活中,就是使用电脑的基本计算指导—代码来计算一些对人类大脑来说可以完成但是会极其困难的问题. 代码?现在我对这个单词已经没有太多的恐惧了,更多的实际上是一些热爱,以及一丝藏在内心深处的疲倦. 言归正传,代码实际上就是文章,通过各种各样的计算机语言来编写的一篇电脑能够理解的完全理性的文章. 计算机语言?计算机语言,一种设计来表达绝对理性的语言,常见的有C),C++,Pascal,HTML,Java,C# 而实际上OI中允许的三种语言是C,C++,Pascal C?最为基础的一种计算机语言,一些过时软件或者一些软件的远古版本的基础架构 C++?听着就跟C有些不可告人的秘密:) C++是在C的基础上改进的语言,全面兼容C的所有语法,并且在此基础上增加了新的语法与运算规则,引入了很多的标准库(比如说你不定义就可以调用的函数们) C++是现在市面上绝大多数的软件的基础架构,也是最为人广知的语言(你不信就去大街上随便哈一个人问:你对编程的第一印象是?八成的回答—C++?) 这两种语言都是拥有极高的编译效率的,也有极高的执行效率 Pascal?与上面两者相似,甚至有共同的语法,但是标准库少之又少,而且运行效率也不如上面两者(即将被OI淘汰的语言) 10]]></content>
      <categories>
        <category>学习方法与知识总结</category>
      </categories>
      <tags>
        <tag>入门详解</tag>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辛普森积分法(Simpson)]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[辛普森一家?Simpson求的函数的图形确实有点神似:)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2012排队题解]]></title>
    <url>%2F2019%2F06%2F18%2FHNOI2012%E6%8E%92%E9%98%9F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[排队,打水? 题目描述某中学有 n 名男同学，m 名女同学和两名老师要排队参加体检。他们排成一条直线，并且任意两名女同学不能相邻，两名老师也不能相邻，那么一共有多少种排法呢？（注意：任意两个人都是不同的） 题目简述：n个男生,m个女生,2个老师,排成一个队列,老师不能相邻,女生不能相邻,每个人不同 算法分析这里有一个神奇的群体叫男生,就像背景一样,没有任何要求 所以?这题实际上就是疯狂把老师和女生丢到男生之间的空里面,由于只有两个老师,我们只用分两种情况: 两个老师之间只有一个女生 两个老师之间有一坨不明觉厉的东西 那么既然是插空,那么就是排列组合乱搞咯. 算法实现 况一 我们既然这个状态如此死板,那我们就直接把它当做一个整体吧! 男生排列:$A_n^n$ 上述总体排列:$A_{n+1}^1$(n+1是因为有n+1个空) 总体中老师排列:$A_2^2$ 剩余女生排列:$A_{n+2}^{m-1}$ 乘起来就完咯 \Large A_n^n \cdot A_{n+1}^1 \cdot A_{n+2}^{m-1} \cdot A_2^2 况二 剩下直接考虑: 男生排列:$A_n^n$ 老师排列:$A_{n+1}^2$ 女生排列:$A_{n+3}^{m}$ 又乘起来咯: \Large A_{n}^{n} \cdot A_{n+1}^2 \cdot A_{n+3}^m代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define ull unsigned long long#define db double#define ldb long db#define si short int#define bl bool#define mem(a) memset(a,0,sizeof(a))#define mee(a,b) memset(a,b,sizeof(a))#define setnum(a,b,c) for(int kkk=1;i&lt;=b;i++)a[kkk]=c[kkk];#define setnums(a,b,c) for(int kkk=1;kkk&lt;=b;kkk++)a[kkk]=c;#define maxn 20015#define maxm#define inf 0x7fffffff#define r(a) a=read()#define w(a) write(a);puts("")#define W(a) write(a);printf(" ")#define For(a,b,c) for(int a=b;a&lt;=c;a++)using namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll v[maxn],c[maxn];ll n,m;void times(ll a[],ll val)&#123; for(register ll i=1;i&lt;=a[0];i++)a[i]*=val; for(register ll i=1;i&lt;=a[0];i++) &#123; a[i+1]+=a[i]/10;a[i]%=10; &#125; while(a[a[0]+1])&#123;a[0]++;a[a[0]+1]+=a[a[0]]/10;a[a[0]]%=10;&#125;&#125;void add(ll a[],ll b[])&#123; a[0]=max(a[0],b[0])+1; for(register ll i=1;i&lt;=a[0];i++) &#123; a[i]+=b[i]; &#125; for(register ll i=1;i&lt;=a[0];i++) &#123; a[i+1]+=a[i]/10;a[i]%=10; &#125; if(!a[a[0]])a[0]--;&#125;void print(ll a[])&#123; for(register ll i=a[0];i&gt;=1;i--)printf("%lld",a[i]); printf("\n");&#125;int main()&#123; n=read(); m=read(); v[0]=v[1]=c[0]=c[1]=1; times(v,n); for(register ll i=1;i&lt;=n+1;i++)times(v,i); for(register ll i=n+4-m;i&lt;=n+3;i++)times(v,i); if(m)&#123; for(register ll i=1;i&lt;=n+1;i++)times(c,i); for(register ll i=n-m+4;i&lt;=n+2;i++)times(c,i); times(c,2); times(c,m); add(v,c); &#125; print(v); return 0;&#125; Tips数据很大，又不取模，你猜要不要高精度？]]></content>
      <categories>
        <category>题解</category>
        <category>省选</category>
        <category>HNOI</category>
        <category>2012</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2011卡农题解]]></title>
    <url>%2F2019%2F06%2F18%2FHNOI2011%E5%8D%A1%E5%86%9C%2F</url>
    <content type="text"><![CDATA[这大概是我第一道听懂了的容斥题了吧(入门那种不算) 题意描述众所周知卡农是一种复调音乐的写作技法，小余在听卡农音乐时灵感大发，发明了一种新的音乐谱写规则。他将声音分成 n 个音阶，并将音乐分成若干个片段。音乐的每个片段都是由 1 到 n 个音阶构成的和声，即从 n 个音阶中挑选若干个音阶同时演奏出来。为了强调与卡农的不同，他规定任意两个片段所包含的音阶集合都不同。同时为了保持音乐的规律性，他还规定在一段音乐中每个音阶被奏响的次数为偶数。现在的问题是：小余想知道包含 m 个片段的音乐一共有多少种。两段音乐 a 和 b 同种当且仅当将 a 的片段重新排列后可以得到 b。例如：假设 a为(1,2),(2,3)，b 为(3,2),(2,1)，那么 a 与 b 就是同种音乐。由于种数很多，你只需要输出答案模 100000007（质数）的结果。 题意简述有一个集:$S{1,2,3,\cdots,n}$让你在里面选择$m$个集合并且满足如下性质: 不能为空集 没有重复的集合 每个元素的总出现次数必定为偶数次 分析一波主要算法分析首先我们可以很显然地知道不一定满足上述三个条件的所有情况:$A_{2^n}^{i}$但是这里我们也显然可以排除空集情况,变成:$A_{2^n -1}^{i}$那么我们既然可以知道所有的情况，也知道用来排除错误情况的条件,那么就显然容斥咯(说的自在,自己还不是没想出来) 算法实现分析分析上述三点条件,发现第三条能够实现从选择了$i-1$个集合具体状态直接推导出选择了$i$个的状态 $f[i]:$选择i个集合的可能状态数 所以选i个的状态数被排除到了$A_{2^n -1}^{i-1}$ 那么再用条件1推导:发现如果要当前选择集合为空集,那么前i-1个就一定能够组成一个合法状态,所以,条件1又排除掉了$f[i-1]$个状态 最后再来看条件2:首先,假设第$i$(也就是当前选择的最后一个集合)和$j(j&lt;i)$集合完全相同且这个状态除了这个问题没有违反任何条件,那么显然去掉集合$i$与集合$j$剩下的i-2个集合能够组成一个符合条件的状态,而$j$有$i-1$个位置可选,以及$2^n -1-(i-2)$个集合可选而去掉$i$和$j$之后符合条件的状态数为$f[i-2]$,按照乘法原理,我们又排除了$f[i-2]\cdot(i-1)\cdot (2^n -1-(i-2))$个状态 so?! f[i]=A_{2^n-1}^{i-1}-f[i-1]-f[i-2]\cdot(i-1)\cdot (2^n -1-(i-2))\\ f[i]=A_{2^n-1}^{i-1}-f[i-1]-f[i-2]\cdot(i-1)\cdot (2^n+1-i)\\12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;map&gt;#include&lt;set&gt;#define ll long long#define db double#define mod 100000007#define maxn 1000005using namespace std;ll max(ll a,ll b)&#123;if(a&gt;b)return a;return b;&#125;ll min(ll a,ll b)&#123;if(a&lt;b)return a;return b;&#125;ll read()&#123; ll ans=0,fh=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123; if(c=='-')fh=-1; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123; ans=ans*10+c-'0'; c=getchar(); &#125; return ans*fh;&#125;ll n,m,f[maxn],MX=1,A[maxn],qwq;ll Pow(ll x,ll y,ll p)&#123; ll ret=1; while(y)&#123; if(y&amp;1)(ret*=x)%=p; (x*=x)%=p; y&gt;&gt;=1; &#125; return ret%mod;&#125;int main()&#123; n=read();m=read(); if(m==1||m==2)&#123;puts("0");return 0;&#125; f[1]=0;f[2]=0; A[0]=1;qwq=1; for(int i=1;i&lt;=n;i++)(qwq*=2)%=mod; for(int i=1;i&lt;=m;i++)&#123; A[i]=A[i-1]*(qwq-i)%mod; &#125; for(int i=3;i&lt;=m;i++)&#123; f[i]=(A[i-1]-f[i-1]+mod-f[i-2]*(i-1)%mod*(qwq-i+1)%mod+mod)%mod; &#125; for(int i=1;i&lt;=m;i++)(MX*=i)%=mod; cout&lt;&lt;f[m]*Pow(MX,mod-2,mod)%mod; return 0;&#125; 完结撒花！]]></content>
      <categories>
        <category>题解</category>
        <category>省选</category>
        <category>HNOI</category>
        <category>2011</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树网的核]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[偏门的知识点,但是很好玩啊 前置知识树的直径定义:树上最长的链 适用范围:显然:树 求解方式: 从任意一个点DFS并且存下到每个点到这个点的距离 然后从距离最远的那个点又DFS一遍,这次找到的最大的距离就是直径 :但是,还有一个问题:怎么存下来直径上的每一个点(任意一条) 其实也很简单,在第二遍的DFS时保存每个点的Father 然后从最后找到的那个远点一直找Father并且把每个点统计起来就是了 算法主体问题描述给定一颗树(无根) 求一条路径,使得其他点到这条路径的最大距离最小$(n&lt;=300000)$,并且使得这条路径的长度$\le s$ 算法分析暴力呵呵 分析一波显然,这条路径肯定在直径上(感性证明) 然后呢? 直径上每一个点记能延伸出去的最长距离为$f[x]$ 那么显然,对于选定路径x到y: 我们定义:$u\in(x,y)$,$s$为直径起点,$t$为直径终点 ans=max(max(f[u]),len(s,x),len(y,t))于是我们就得到了$n^2$的算法 然而:$n&lt;=300000$ 所以我们需要一个$O(n)$的算法 最终算法其实很简单,我们有两个优化: 优化1：我们不需要与每一个$f[u]$比较,而是直接与所有$f[u]$的最大值$fmax$比较 然而正确性？ 设 $fmax$是由点$p$延伸出来的 $s,t$分别是直径的起点与终点 那么我们可以分为两种情况: 况1:$p\in(x,y)$ 这很显然正确,因为它和之前没有任何区别 况2:$p\notin(x,y)$ 这个时候明显$len(s,x)\ge fmax$或$len(y,t)\ge fmax$ 为什么? 我们采用反证 假设$len(s,x)\le fmax$或$len(y,t)\le fmax$ 那么明显直径应该以延伸到$fmax$那一条链上,假设不成立 综上:我们可以直接和$fmax$比较,而不是每次都和$n$个比较 得证:)优化2:明显当一条链延长的时候它的解只可能变得更优 证明就免了吧 经过$sun123zxy$的反复询问我还是把证明写出来吧: 况1:当前的最大值是从$x$或$y$并且在直径上扩展出去的 那么当我们扩展的时候$len(s,x)$与$len(y,t)$中的一项必然变小(否则你就没有扩展啊) 况2:当前的最大值是$fmax$而反观我们的式子$max(fmax,len(s,x),len(x,t))$ 当我们扩展的时候$len(s,x)$与$len(y,t)$中的两项不会由任何一项变大,所以最大值仍为$fmax$ 综上:当我们扩展这条链时,答案显然不会变得更劣 得证:)于是我们就可以直接用两个指针在$O(n)$的时间复杂度内实现路径的枚举 代码代码框架: 前向星 DFS求直径 通过爬father的过程来找直径上的具体点 然后同时使用两个指针维护枚举路径 具体实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define ll long long#define bl bool#define mem(a) memset(a,0,sizeof(a))#define maxn 500005#define maxm 2000005#define inf 0x7fffffffusing namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;ll n,s,cnt,h[maxn],ff,tt,le,rt,dis,f[maxn],now,Fmax,bian[maxn];vector&lt;ll&gt;r;bl flg[maxn];struct Edge&#123;ll f,t,l,next;&#125;e[maxm];void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,l,h[f]&#125;;h[f]=cnt;&#125;void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125;void Getr(ll u,ll fa,ll d)&#123; f[u]=fa;ll v; if(d&gt;dis)&#123;dis=d;rt=u;&#125; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].t;if(v==fa)continue; Getr(v,u,d+e[i].l); &#125;&#125;void GetR(ll u)&#123; while(f[u])&#123;r.push_back(u);u=f[u];flg[u]=1;&#125; r.push_back(u);flg[u]=1;&#125;void Dfs(ll u,ll fa,ll l)&#123; ll v;Fmax=Max(Fmax,l); for(int i=h[u];i;i=e[i].next)&#123; v=e[i].t;if(v==fa)continue; if(flg[v])Dfs(v,u,0),bian[u]=e[i].l; else Dfs(v,u,l+e[i].l); &#125;&#125;int main()&#123; n=read();s=read(); for(int i=1;i&lt;n;i++)&#123; ff=read();tt=read();le=read(); madd(ff,tt,le); &#125; dis=0;rt=0; Getr(1,0,0); dis=0;mem(bian); Getr(rt,0,0); GetR(rt); Dfs(rt,0,0); ll p1=0,p2=0,len=0,L=0,ltot=0,ans=inf; for(int i=0;i&lt;r.size();i++)ltot+=bian[r[i]]; while(p2&lt;=r.size())&#123; while(1)&#123; if(len+bian[r[p2]]&lt;=s&amp;&amp;p2&lt;r.size()-1)&#123; len+=bian[r[p2]]; p2++; &#125; else break; &#125; ans=Min(ans,Max(L,ltot-len-L)); len-=bian[r[p1]]; L+=bian[r[p1]]; p1++;p2=Max(p1,p2); &#125; ans=Max(ans,Fmax); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 温馨提示:fmax为一个库函数名 例题:(luogu)P1099-树网的核 (luogu)P2491-[SDOI2011]消防 就是一道题,也只有一道模板题 个人认为这个知识点很难考 因为这个知识点一旦需要套,那么就明显需要知道具体哪条路径 然而这样你就没法优化了啊(实际上优化2能用) 完:)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
        <category>树的直径</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>树的直径</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆方树]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%9C%86%E6%96%B9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[emm，由方点和圆点组成的树。(命名鬼才) 前置芝士仙人掌图 仙人掌图是一个无向连通图 仙人掌图上的任意边都至多存在于一个环里 为什么叫仙人掌图你自己画出来就知道了 基环树emm,只有一个环的仙人掌,想看也可以去看看 进入正题什么是圆♂方树? 圆方树就是一个用树来表达仙人掌的一种方式(方表示环,圆表示点) 对于一个环,我们定义一个根,作为从原图根(已指定)节点DFS下来遇到的第一个这个环上的节点 那么这个节点就是这个环在圆方树上的爸爸,而这个环上的其他节点则是这个环在树上的儿子 emm,就这样 怎么建圆♂方树?well,观察一下: —一个环就是一个联通分量 —一个联通分量里有且只有一个环 —每一个联通分量都是一个点双联通分量 很美妙的性质,似乎每一条性质都将我们引向一个毒瘤老爷子 但是这明显不是一个简单的tarjan(tbyangz:哪里不简单了) —首我们仍按照正常tarjan跑,当我们找到了一个联通分量的时候,这就是个环了 —这个时候我们正处在的点,就是该环的环根了 (想想为什么) —新建一个方点并把当前找到的联通分量中的所有点都与之连边(保留原编号) —另外,如果搜到自己儿子与自己不在同一个联通分量中,就从自己向儿子连边(作圆方树边) 就酱 123456789101112131415161718192021222324252627282930313233343536ll n,m,q,ff,tt,le,N,dfn[maxn],low[maxn],tot,h[maxn],cnt=1,H[maxn],Cnt;struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm];void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125;void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125;void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125;void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125;stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn];void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].from; len1[e[now_edge].from]=W; if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; N++; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125;&#125; 其实确实挺简单的对吧 如何使用圆♂方树?掌上最短(长)路例题:luogu P5236-静态仙人掌题目描述:给你一个有nn个点和mm条边的仙人掌图，和qq组询问每次询问两个点u,vu,v，求两点之间的最短路。 输入:第一行三个正整数$n,m,q$意义如题目描述。接下来$m$行，每行三个正整数$u,v,w$表示$u,v$之间有一条权值为$w$的无向边。然后$q$行，每行两个正整数$u,v$询问$u$到$v$的最短路。 输出:$q$行，每行一个正整数，对应一次询问的结果。 数据范围$1≤n,q≤10000$$1≤m≤20000$$1≤w≤10^9$ 思路分析:暴力?呵呵。 SPFA&amp;Dijkstra?$O(nm)$的时间,你要是i9-9900k的话你跑得过去我没话说,可惜你不是.(实测跑不过去) 还能怎么做?冷静分析一波,这道题基本上时间要求$O(n log(m))$之类的神奇东西 然鹅,最短路能到$O(nlog(m))$的也就只有LCA了 不可做不可做 等等仙人掌? LCA? 圆方树啊!!! :) 圆方树上LCA其实说出来就没什么好讲的了 实际上有: —DFS确定每个点的爸爸 —预处理计算出ST数组 —回答询问 还有一个神奇的坑点(实际不坑): 当两个点的LCA是方点时,你需要特判最后两个点的距离 For example: 也就是两个换上的点之间的路径从上走还是从下走 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define si short int#define bl bool#define maxn 30000#define maxm 50000#define inf 0x7fffffffusing namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll n,m,q,ff,tt,le,N,dfn[maxn],low[maxn],tot,h[maxn],cnt=1,H[maxn],Cnt;struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm];void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125;void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125;void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125;void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125;stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn];void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].from; len1[e[now_edge].from]=W; if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; N++; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125;&#125;ll ST[maxn][21],dep[maxn],dis[maxn][21];void Dfs(ll u,ll fa)&#123; ll v;ST[u][0]=fa;dep[u]=dep[fa]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)&#123; ST[u][i]=ST[ST[u][i-1]][i-1]; dis[u][i]=dis[u][i-1]+dis[ST[u][i-1]][i-1]; &#125; for(int i=H[u];i;i=E[i].next)&#123; v=E[i].to;if(v==fa)continue; dis[v][0]=E[i].len;Dfs(v,u); &#125;&#125;ll que(ll x,ll y)&#123; ll ans=0,xx=x,yy=y; if(dep[x]&lt;dep[y])swap(x,y); for(int i=17;i&gt;=0;i--) if(dep[ST[x][i]]&gt;=dep[y]) ans+=dis[x][i],x=ST[x][i]; if(x==y)return ans; for(int i=17;i&gt;=0;i--) if(ST[x][i]!=ST[y][i])&#123; ans+=dis[x][i]+dis[y][i]; x=ST[x][i];y=ST[y][i]; &#125; if(ST[x][0]&gt;n)return ans+Min(Min(len1[x]+len2[y],len1[y]+len2[x]),abs(len1[x]-len1[y])); ans+=dis[x][0]+dis[y][0]; x=ST[x][0];y=ST[y][0]; return ans;&#125;int main()&#123; N=n=read();m=read();q=read(); for(int i=1;i&lt;=m;i++)&#123;ff=read();tt=read();le=read();madd(ff,tt,le);&#125; Tarjan(1,0); Dfs(1,0); for(int i=1;i&lt;=q;i++)write(que(read(),read())),puts(""); return 0;&#125; 码风略丑,别介意 掌上DP例题:luogu P4410-无归岛题目描述:Neverland是个神奇的地方，它由一些岛屿环形排列组成，每个岛上都生活着之中与众不同的物种。 但是这些物种都有一个共同的生活习性：对于同一个岛上的任意两个生物，他们有且仅有一个公共朋友，即对同一岛上的任意两个生物a和b有且仅有一个生物c既是a的朋友也是b的朋友，当然某些岛上也可能会只有一个生物孤单地生活着。 这一习性有一个明显的好处，当两个生物发生矛盾的时候，他们可以请那个唯一的公共朋友来裁决谁对谁错。 另外，岛与岛之间也有交流，具体来说，每个岛都会挑选出一个最聪明的生物做代表，然后这个生物与他相邻的两个岛的代表成为朋友。 不幸运的是，A世界准备入侵Neverland，作为Neverland的守护者，Lostmonkey想知道在一种比较坏的情况下Never的战斗力。因为和朋友并肩作战，能力会得到提升，所以Lostmonkey想知道在不选出一对朋友的情况下Neverland的最大战斗力。即选出一些生物，且没有一对生物是朋友，并且要求它们的战斗力之和最大。 输入:第一行包含用空格隔开的两个整数n和m，分别表示Neverland的生物种数和朋友对数。 接下来的m行描述所有朋友对，具体来说，每行包含用空格隔开的两个整数a和b，表示生物a和生物b是朋友（每对朋友只出现一次）。第m+2行包含用空格隔开的n个整数，其中第i个整数表示生物i的战斗力A. 输出:仅包含一个整数，表示满足条件的最大战斗力. 数据范围:输入数据保证$4≤n≤100000,1≤a,b≤n,1≤m≤200000,−1000≤Ai≤1000。$ 思路分析:算法分析:实际上呢,这个就是一个带权最大独立集 SO-&gt;DP!! 问题来了,这DP个鬼啊,不是树啊啊啊 冷静,冷静 我们需要一棵树,但是仙人掌可以用圆方树转为树 欢乐地DP!!! [pic 欢乐] 首先是状态:我们肯定需要一维点对吧,但是一维明显很难维护所以我们就需要第二维-&gt;当前点取与不取 $ f[x][0/1]: $点x的子树中取$(1)$或不取$(0)$x时最大独立集的权值 然后是状态转移方程那么对于原点: f[x][1]=\sum_{y\in son[x]}f[y][0]\\ f[x][0]=\sum_{y\in son[x]}max(f[y][0],f[y][1])而对于方点,我们还需要一个环上辅助DP: 这里我们分取环根与不取环根两种情况讨论,但他们的状态转移方程是一样的 g[i][1]=f[v][1]+g[i-1][0]\\ g[i][0]=f[v][0]+max(g[i-1][0],g[i-1][1])这里将所有的环上节点存入了代表这个环的$vector$ 所以这里的$i$是在枚举$vector$中元素时用的指针 而$v$则是$vector$中第$i$个元素代表的点的编号 So, that’s it! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define ull unsigned long long#define db double#define ldb long db#define si short int#define bl bool#define mem(a) memset(a,0,sizeof(a))#define mee(a,b) memset(a,b,sizeof(a))#define setnum(a,b,c) for(int kkk=1;i&lt;=b;i++)a[kkk]=c[kkk];#define setnums(a,b,c) for(int kkk=1;kkk&lt;=b;kkk++)a[kkk]=c;#define maxn 200005#define maxm 500005#define inf 0x7fffffff#define r(a) a=read()#define w(a) write(a);puts("")#define W(a) write(a);printf(" ")#define For(a,b,c) for(int a=b;a&lt;=c;a++)using namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll n,m,f[maxn][2],g[maxn][2],ff,tt,le;namespace cst&#123; ll N,h[maxn],cnt=1,dfn[maxn],low[maxn],H[maxn],Cnt,tot,rf[maxn]; vector&lt;ll&gt;ring[maxn]; struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm]; void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125; void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125; void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125; void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125; stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn]; void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; N++;rf[N]=u; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].to; len1[e[now_edge].to]=W; ring[N].push_back(e[now_edge].to); if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125; &#125;&#125;using namespace cst;void Rdp(ll u)&#123; //不选环根 g[0][0]=f[ring[u][0]][0]; g[0][1]=-inf; ll v; for(int i=1;i&lt;ring[u].size();i++)&#123; v=ring[u][i]; g[i][0]=f[v][0]+Max(g[i-1][0],g[i-1][1]); g[i][1]=f[v][1]+g[i-1][0]; &#125; f[ring[u][0]][0]=Max(g[ring[u].size()-1][0],g[ring[u].size()-1][1]); //选环根 g[0][0]=-inf; g[0][1]=f[ring[u][0]][1]; for(int i=1;i&lt;ring[u].size();i++)&#123; v=ring[u][i]; g[i][0]=f[v][0]+Max(g[i-1][0],g[i-1][1]); g[i][1]=f[v][1]+g[i-1][0]; &#125; f[ring[u][0]][1]=g[ring[u].size()-1][0];&#125;void Tdp(ll u,ll fa)&#123; if(u&lt;=n)f[u][1]=1;ll v; for(int i=H[u];i;i=E[i].next)&#123; v=E[i].to;if(v==fa)continue; Tdp(v,u); if(u&lt;=n&amp;&amp;v&lt;=n)&#123; f[u][0]+=Max(f[v][0],f[v][1]); f[u][1]+=f[v][0]; &#125; &#125; if(u&gt;n)Rdp(u);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++)&#123; ff=read();tt=read(); madd(ff,tt,1); &#125; N=n; Tarjan(1,0); Tdp(1,0); cout&lt;&lt;Max(f[1][0],f[1][1])&lt;&lt;endl; return 0;&#125; 后话这是这个博客的第一篇完整的题解 希望这个博客能够推动我的OI之路走的更远,更高! (撒花) 日常推荐壁纸(我自己p的):[pic shiny mountain] 完]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
        <category>仙人掌</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>圆方树</tag>
        <tag>仙人掌</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
