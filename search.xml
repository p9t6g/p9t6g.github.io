<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[圆方树]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%9C%86%E6%96%B9%E6%A0%91%2F</url>
    <content type="text"><![CDATA[emm，由方点和圆点组成的树。(命名鬼才) 前置芝士仙人掌图 仙人掌图是一个无向连通图 仙人掌图上的任意边都至多存在于一个环里 为什么叫仙人掌图你自己画出来就知道了 基环树emm,只有一个环的仙人掌,想看也可以去看看 进入正题什么是圆♂方树? 圆方树就是一个用树来表达仙人掌的一种方式(方表示环,圆表示点) 对于一个环,我们定义一个根,作为从原图根(已指定)节点DFS下来遇到的第一个这个环上的节点 那么这个节点就是这个环在圆方树上的爸爸,而这个环上的其他节点则是这个环在树上的儿子 emm,就这样 怎么建圆♂方树?well,观察一下: —一个环就是一个联通分量 —一个联通分量里有且只有一个环 —每一个联通分量都是一个点双联通分量 很美妙的性质,似乎每一条性质都将我们引向一个毒瘤老爷子 但是这明显不是一个简单的tarjan(tbyangz:哪里不简单了) —首我们仍按照正常tarjan跑,当我们找到了一个联通分量的时候,这就是个环了 —这个时候我们正处在的点,就是该环的环根了 (想想为什么) —新建一个方点并把当前找到的联通分量中的所有点都与之连边(保留原编号) —另外,如果搜到自己儿子与自己不在同一个联通分量中,就从自己向儿子连边(作圆方树边) 就酱 123456789101112131415161718192021222324252627282930313233343536ll n,m,q,ff,tt,le,N,dfn[maxn],low[maxn],tot,h[maxn],cnt=1,H[maxn],Cnt;struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm];void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125;void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125;void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125;void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125;stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn];void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].from; len1[e[now_edge].from]=W; if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; N++; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125;&#125; 其实确实挺简单的对吧 如何使用圆♂方树?掌上最短(长)路例题:luogu P5236-静态仙人掌题目描述:给你一个有nn个点和mm条边的仙人掌图，和qq组询问每次询问两个点u,vu,v，求两点之间的最短路。 输入:第一行三个正整数$n,m,q$意义如题目描述。接下来$m$行，每行三个正整数$u,v,w$表示$u,v$之间有一条权值为$w$的无向边。然后$q$行，每行两个正整数$u,v$询问$u$到$v​$的最短路。 输出:$q​$行，每行一个正整数，对应一次询问的结果。 数据范围$1≤n,q≤10000$$1≤m≤20000$$1≤w≤10^9​$ 思路分析:暴力?呵呵。 SPFA&amp;Dijkstra?$O(nm)$的时间,你要是i9-9900k的话你跑得过去我没话说,可惜你不是. 还能怎么做?冷静分析一波,这道题基本上时间要求$O(n log(m))$之类的神奇东西 然鹅,最短路能到$O(nlog(m))$的也就只有LCA了 不可做不可做 等等仙人掌? LCA? 圆方树啊!!! :) 圆方树上LCA其实说出来就没什么好讲的了 实际上有: —DFS确定每个点的爸爸 —预处理计算出ST数组 —回答询问 还有一个神奇的坑点(实际不坑): 当两个点的LCA是方点时,你需要特判最后两个点的距离 For example: 也就是两个换上的点之间的路径从上走还是从下走 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define si short int#define bl bool#define maxn 30000#define maxm 50000#define inf 0x7fffffffusing namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll n,m,q,ff,tt,le,N,dfn[maxn],low[maxn],tot,h[maxn],cnt=1,H[maxn],Cnt;struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm];void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125;void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125;void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125;void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125;stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn];void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].from; len1[e[now_edge].from]=W; if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; N++; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125;&#125;ll ST[maxn][21],dep[maxn],dis[maxn][21];void Dfs(ll u,ll fa)&#123; ll v;ST[u][0]=fa;dep[u]=dep[fa]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)&#123; ST[u][i]=ST[ST[u][i-1]][i-1]; dis[u][i]=dis[u][i-1]+dis[ST[u][i-1]][i-1]; &#125; for(int i=H[u];i;i=E[i].next)&#123; v=E[i].to;if(v==fa)continue; dis[v][0]=E[i].len;Dfs(v,u); &#125;&#125;ll que(ll x,ll y)&#123; ll ans=0,xx=x,yy=y; if(dep[x]&lt;dep[y])swap(x,y); for(int i=17;i&gt;=0;i--) if(dep[ST[x][i]]&gt;=dep[y]) ans+=dis[x][i],x=ST[x][i]; if(x==y)return ans; for(int i=17;i&gt;=0;i--) if(ST[x][i]!=ST[y][i])&#123; ans+=dis[x][i]+dis[y][i]; x=ST[x][i];y=ST[y][i]; &#125; if(ST[x][0]&gt;n)return ans+Min(Min(len1[x]+len2[y],len1[y]+len2[x]),abs(len1[x]-len1[y])); ans+=dis[x][0]+dis[y][0]; x=ST[x][0];y=ST[y][0]; return ans;&#125;int main()&#123; N=n=read();m=read();q=read(); for(int i=1;i&lt;=m;i++)&#123;ff=read();tt=read();le=read();madd(ff,tt,le);&#125; Tarjan(1,0); Dfs(1,0); for(int i=1;i&lt;=q;i++)write(que(read(),read())),puts(""); return 0;&#125; 码风略丑,别介意 掌上DP例题:luogu P4410-无归岛题目描述:Neverland是个神奇的地方，它由一些岛屿环形排列组成，每个岛上都生活着之中与众不同的物种。 但是这些物种都有一个共同的生活习性：对于同一个岛上的任意两个生物，他们有且仅有一个公共朋友，即对同一岛上的任意两个生物a和b有且仅有一个生物c既是a的朋友也是b的朋友，当然某些岛上也可能会只有一个生物孤单地生活着。 这一习性有一个明显的好处，当两个生物发生矛盾的时候，他们可以请那个唯一的公共朋友来裁决谁对谁错。 另外，岛与岛之间也有交流，具体来说，每个岛都会挑选出一个最聪明的生物做代表，然后这个生物与他相邻的两个岛的代表成为朋友。 不幸运的是，A世界准备入侵Neverland，作为Neverland的守护者，Lostmonkey想知道在一种比较坏的情况下Never的战斗力。因为和朋友并肩作战，能力会得到提升，所以Lostmonkey想知道在不选出一对朋友的情况下Neverland的最大战斗力。即选出一些生物，且没有一对生物是朋友，并且要求它们的战斗力之和最大。 输入:第一行包含用空格隔开的两个整数n和m，分别表示Neverland的生物种数和朋友对数。 接下来的m行描述所有朋友对，具体来说，每行包含用空格隔开的两个整数a和b，表示生物a和生物b是朋友（每对朋友只出现一次）。第m+2行包含用空格隔开的n个整数，其中第i个整数表示生物i的战斗力A. 输出:仅包含一个整数，表示满足条件的最大战斗力. 数据范围:输入数据保证$4≤n≤100000,1≤a,b≤n,1≤m≤200000,−1000≤Ai≤1000。$ 思路分析:算法分析:实际上呢,这个就是一个带权最大独立集 SO-&gt;DP!! 问题来了,这DP个鬼啊,不是树啊啊啊 冷静,冷静 我们需要一棵树,但是仙人掌可以用圆方树转为树 欢乐地DP!!! [pic 欢乐] 首先是状态:我们肯定需要一维点对吧,但是一维明显很难维护所以我们就需要第二维-&gt;当前点取与不取 $ f[x][0/1]: $点x的子树中取$(1)$或不取$(0)​$x时最大独立集的权值 然后是状态转移方程那么对于原点: f[x][1]=\sum_{y\in son[x]}f[y][0]\\ f[x][0]=\sum_{y\in son[x]}max(f[y][0],f[y][1])而对于方点,我们还需要一个环上辅助DP: 这里我们分取环根与不取环根两种情况讨论,但他们的状态转移方程是一样的 g[i][1]=f[v][1]+g[i-1][0]\\ g[i][0]=f[v][0]+max(g[i-1][0],g[i-1][1])这里将所有的环上节点存入了代表这个环的$vector$ 所以这里的$i$是在枚举$vector$中元素时用的指针 而$v$则是$vector$中第$i$个元素代表的点的编号 So, that’s it! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define ll long long#define ull unsigned long long#define db double#define ldb long db#define si short int#define bl bool#define mem(a) memset(a,0,sizeof(a))#define mee(a,b) memset(a,b,sizeof(a))#define setnum(a,b,c) for(int kkk=1;i&lt;=b;i++)a[kkk]=c[kkk];#define setnums(a,b,c) for(int kkk=1;kkk&lt;=b;kkk++)a[kkk]=c;#define maxn 200005#define maxm 500005#define inf 0x7fffffff#define r(a) a=read()#define w(a) write(a);puts("")#define W(a) write(a);printf(" ")#define For(a,b,c) for(int a=b;a&lt;=c;a++)using namespace std;ll Min(ll x,ll y)&#123;if(x&lt;y)return x;return y;&#125;ll Max(ll x,ll y)&#123;if(x&gt;y)return x;return y;&#125;ll read()&#123; ll s=0,h=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')h=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;s=s*10+c-'0';c=getchar();&#125; return s*h;&#125;void write(ll x)&#123; if(x&gt;9)&#123; si tmp=x%10; write(x/10); putchar(tmp+'0'); &#125; else putchar(x+'0');&#125;ll Pow(ll x,ll y,ll p)&#123; ll ans=1; while(y)&#123; if(y&amp;1)ans=ans*x%p; x=x*x%p;y&gt;&gt;=1; &#125; return ans;&#125;ll n,m,f[maxn][2],g[maxn][2],ff,tt,le;namespace cst&#123; ll N,h[maxn],cnt=1,dfn[maxn],low[maxn],H[maxn],Cnt,tot,rf[maxn]; vector&lt;ll&gt;ring[maxn]; struct Edge&#123;ll from,to,next,len;&#125;e[maxm],E[maxm]; void add(ll f,ll t,ll l)&#123;e[++cnt]=&#123;f,t,h[f],l&#125;;h[f]=cnt;&#125; void madd(ll f,ll t,ll l)&#123;add(f,t,l);add(t,f,l);&#125; void Add(ll f,ll t,ll l)&#123;E[++Cnt]=&#123;f,t,H[f],l&#125;;H[f]=Cnt;&#125; void Madd(ll f,ll t,ll l)&#123;Add(f,t,l);Add(t,f,l);&#125; stack&lt;ll&gt;st;ll V[maxn],Vtop,now_edge,len1[maxn],len2[maxn]; void Tarjan(ll u,ll pre_edge)&#123; dfn[u]=low[u]=++tot;ll v; for(int i=h[u];i;i=e[i].next)&#123; v=e[i].to; if(i==(pre_edge^1))continue; if(!dfn[v])&#123; st.push(i); Tarjan(v,i); low[u]=Min(low[u],low[v]); if(low[v]&gt;dfn[u])st.pop(),Madd(u,v,e[i].len); if(low[v]==dfn[u])&#123; ll W=0;Vtop=0; N++;rf[N]=u; while(1)&#123; now_edge=st.top();st.pop(); W+=e[now_edge].len; V[++Vtop]=e[now_edge].to; len1[e[now_edge].to]=W; ring[N].push_back(e[now_edge].to); if(e[now_edge].from==u&amp;&amp;e[now_edge].to==v)break; &#125; for(int i=1;i&lt;=Vtop;i++)&#123; len2[V[i]]=W-len1[V[i]]; Madd(N,V[i],min(len1[V[i]],len2[V[i]])); &#125; &#125; &#125; else if(dfn[v]&lt;dfn[u])&#123;st.push(i);low[u]=Min(low[u],dfn[v]);&#125; &#125; &#125;&#125;using namespace cst;void Rdp(ll u)&#123; //不选环根 g[0][0]=f[ring[u][0]][0]; g[0][1]=-inf; ll v; for(int i=1;i&lt;ring[u].size();i++)&#123; v=ring[u][i]; g[i][0]=f[v][0]+Max(g[i-1][0],g[i-1][1]); g[i][1]=f[v][1]+g[i-1][0]; &#125; f[ring[u][0]][0]=Max(g[ring[u].size()-1][0],g[ring[u].size()-1][1]); //选环根 g[0][0]=-inf; g[0][1]=f[ring[u][0]][1]; for(int i=1;i&lt;ring[u].size();i++)&#123; v=ring[u][i]; g[i][0]=f[v][0]+Max(g[i-1][0],g[i-1][1]); g[i][1]=f[v][1]+g[i-1][0]; &#125; f[ring[u][0]][1]=g[ring[u].size()-1][0];&#125;void Tdp(ll u,ll fa)&#123; if(u&lt;=n)f[u][1]=1;ll v; for(int i=H[u];i;i=E[i].next)&#123; v=E[i].to;if(v==fa)continue; Tdp(v,u); if(u&lt;=n&amp;&amp;v&lt;=n)&#123; f[u][0]+=Max(f[v][0],f[v][1]); f[u][1]+=f[v][0]; &#125; &#125; if(u&gt;n)Rdp(u);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;i++)&#123; ff=read();tt=read(); madd(ff,tt,1); &#125; N=n; Tarjan(1,0); Tdp(1,0); cout&lt;&lt;Max(f[1][0],f[1][1])&lt;&lt;endl; return 0;&#125; 后话这是这个博客的第一篇完整的题解 希望这个博客能够推动我的OI之路走的更远,更高! (撒花) 日常推荐壁纸(我自己p的):[pic shiny mountain] 完]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
        <category>仙人掌</category>
      </categories>
      <tags>
        <tag>圆方树</tag>
        <tag>图论</tag>
        <tag>仙人掌</tag>
        <tag>学习笔记</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ETT(Euler Tour Tree)]]></title>
    <url>%2F2019%2F04%2F16%2FETT%2F</url>
    <content type="text"><![CDATA[emm，看起来难出天际线，实际上呢，有LF葡萄的讲解就很好懂了]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT填坑]]></title>
    <url>%2F2019%2F04%2F16%2FLCT%2F</url>
    <content type="text"><![CDATA[毕竟咕了两个多月了，还是写写LCT吧，顺便当这个博客第一篇正式文章 哈哈继续咕]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[It’s the first thing that you should learn in C++ or any other languege. First, you need a #include. 1#include&lt;iostream&gt; And than a namespace. 1using namespace std; After that, a main(). 1int main()&#123;&#125; The last thing. 1cout&lt;&lt;"Hello World!"&lt;&lt;endl; And put them together! 12345#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello Wolrd!"&lt;&lt;endl;&#125; Congradulations!!!]]></content>
      <tags>
        <tag>C++入门</tag>
      </tags>
  </entry>
</search>
